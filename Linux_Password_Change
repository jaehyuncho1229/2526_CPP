#!/bin/bash

#############################################
# Linux Password Change Script
# Supports single and batch password changes
#############################################

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to display usage
usage() {
    echo "Usage: $0 [OPTIONS]"
    echo "Options:"
    echo "  -u USERNAME    Change password for specific user"
    echo "  -p PASSWORD    New password (use with caution)"
    echo "  -f FILE        Batch change from file (format: username:password)"
    echo "  -g             Generate random password"
    echo "  -l LENGTH      Password length for generation (default: 16)"
    echo "  -h             Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 -u john -g              # Generate random password for john"
    echo "  $0 -u john -p NewPass123   # Set specific password for john"
    echo "  $0 -f users.txt            # Batch change from file"
    exit 1
}

# Function to generate random password
generate_password() {
    local length=${1:-16}
    # Generate password with uppercase, lowercase, numbers, and special characters
    local password=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-$length)
    # Ensure complexity
    while [[ ! "$password" =~ [A-Z] ]] || [[ ! "$password" =~ [a-z] ]] || [[ ! "$password" =~ [0-9] ]]; do
        password=$(openssl rand -base64 48 | tr -d "=+/" | cut -c1-$length)
    done
    echo "$password"
}

# Function to validate password complexity
validate_password() {
    local password=$1
    local min_length=8
    
    if [[ ${#password} -lt $min_length ]]; then
        echo -e "${RED}Error: Password must be at least $min_length characters${NC}"
        return 1
    fi
    
    if [[ ! "$password" =~ [A-Z] ]]; then
        echo -e "${RED}Error: Password must contain at least one uppercase letter${NC}"
        return 1
    fi
    
    if [[ ! "$password" =~ [a-z] ]]; then
        echo -e "${RED}Error: Password must contain at least one lowercase letter${NC}"
        return 1
    fi
    
    if [[ ! "$password" =~ [0-9] ]]; then
        echo -e "${RED}Error: Password must contain at least one number${NC}"
        return 1
    fi
    
    return 0
}

# Function to change single user password
change_single_password() {
    local username=$1
    local password=$2
    
    # Check if user exists
    if ! id "$username" &>/dev/null; then
        echo -e "${RED}Error: User '$username' does not exist${NC}"
        return 1
    fi
    
    # Validate password
    if ! validate_password "$password"; then
        return 1
    fi
    
    # Change password using chpasswd
    echo "$username:$password" | chpasswd
    
    if [ $? -eq 0 ]; then
        echo -e "${GREEN}✓ Password changed successfully for user: $username${NC}"
        
        # Force password change on next login (optional)
        # chage -d 0 $username
        
        # Log the change
        logger -t password-change "Password changed for user $username by $USER"
        
        # Store in secure location (optional - uncomment if needed)
        # echo "$(date '+%Y-%m-%d %H:%M:%S') - User: $username - Password: $password" >> /root/.password_changes.log
        # chmod 600 /root/.password_changes.log
        
        return 0
    else
        echo -e "${RED}✗ Failed to change password for user: $username${NC}"
        return 1
    fi
}

# Function to change passwords from file
batch_change_passwords() {
    local file=$1
    local success_count=0
    local fail_count=0
    
    if [ ! -f "$file" ]; then
        echo -e "${RED}Error: File '$file' not found${NC}"
        return 1
    fi
    
    echo -e "${YELLOW}Starting batch password change...${NC}"
    echo "----------------------------------------"
    
    while IFS=: read -r username password; do
        # Skip empty lines and comments
        [[ -z "$username" || "$username" =~ ^# ]] && continue
        
        if change_single_password "$username" "$password"; then
            ((success_count++))
        else
            ((fail_count++))
        fi
        
        echo "----------------------------------------"
    done < "$file"
    
    echo -e "${GREEN}Batch operation completed:${NC}"
    echo -e "${GREEN}  ✓ Successful: $success_count${NC}"
    echo -e "${RED}  ✗ Failed: $fail_count${NC}"
}

# Function to securely read password from stdin
read_password_securely() {
    local password
    echo -n "Enter new password: "
    read -s password
    echo
    echo -n "Confirm password: "
    local password_confirm
    read -s password_confirm
    echo
    
    if [ "$password" != "$password_confirm" ]; then
        echo -e "${RED}Error: Passwords do not match${NC}"
        exit 1
    fi
    
    echo "$password"
}

# Main script logic
main() {
    # Check if running as root
    if [ "$EUID" -ne 0 ]; then
        echo -e "${RED}Error: This script must be run as root${NC}"
        exit 1
    fi
    
    # Parse command line arguments
    local username=""
    local password=""
    local file=""
    local generate=false
    local length=16
    
    while getopts "u:p:f:gl:h" opt; do
        case $opt in
            u) username="$OPTARG" ;;
            p) password="$OPTARG" ;;
            f) file="$OPTARG" ;;
            g) generate=true ;;
            l) length="$OPTARG" ;;
            h) usage ;;
            *) usage ;;
        esac
    done
    
    # Batch mode
    if [ -n "$file" ]; then
        batch_change_passwords "$file"
        exit $?
    fi
    
    # Single user mode
    if [ -n "$username" ]; then
        # Generate password if requested
        if [ "$generate" = true ]; then
            password=$(generate_password $length)
            echo -e "${YELLOW}Generated password: $password${NC}"
        elif [ -z "$password" ]; then
            # If no password provided, read securely
            password=$(read_password_securely)
        fi
        
        change_single_password "$username" "$password"
        exit $?
    fi
    
    # No valid options provided
    usage
}

# Run main function
main "$@"
